# Project-Specific Context for CEP

## What This Project Is

CEP (Context Engineering Program) is a personal developer platform that gives AI
coding agents consistent structure for decision-making, documentation, and
communication. It's the system that produces the CLAUDE.md you're reading right now.

CEP manages multiple projects. Each project gets a `.cep/` directory with session
logs, a Mikado tree, ADRs, a guidebook, and blog posts. A single CLI tool (`cep`)
scaffolds new projects, upgrades them when the template changes, and tracks status
across the portfolio.

CEP currently manages two projects: **filebrain** (local file indexing and RAG) and
**itself** (dogfooding).

## Design Principles

1. **One template, many projects.** The base template (`templates/CLAUDE.md.base`)
   defines all conventions. Per-project context lives in `.cep/CLAUDE.local.md`.
   Fix a problem once, upgrade everywhere with `cep upgrade`.

2. **Bash-first, no dependencies.** The CLI is a single bash script. No build system,
   no package manager, no runtime beyond bash and coreutils. This keeps the tool
   instantly usable on any Linux machine and eliminates an entire class of "it doesn't
   work on my setup" problems. The Go rewrite is on the roadmap for when the feature
   set stabilizes — not before.

3. **Human learning is the priority.** The documentation conventions — guidebooks,
   blogs, annotated session logs — exist so that Raymond becomes a better engineer
   by reviewing the agent's work. The guidebook voice ("a generalist engineer who's
   seen everything before but needs explicit reminders") is the product's defining
   feature. Protect it fiercely.

4. **Start simple, rewrite later.** Working and simple beats elegant and unfinished.
   The current bash CLI is ~250 lines and covers init, status, list, upgrade, and
   diff. That's enough. Don't abstract prematurely.

## Tech Stack

- **Language:** Bash (POSIX-compatible where practical, bashisms allowed)
- **Text processing:** sed, awk, grep — standard coreutils
- **Template engine:** sed for simple substitutions, awk for multiline replacements
- **Data format:** YAML for Mikado trees and session index, Markdown for everything else
- **Version control:** Git (the CLI stores a version marker in `.cep/version`)
- **Registry:** Plain text file at `.registry/projects` (one path per line, gitignored)

## The Self-Referential Firewall

CEP is managing its own development. This creates a loop: the agent reads CLAUDE.md
(assembled from the template), then may edit the template that CLAUDE.md was built
from. This is safe because of a natural firewall:

- **At session start:** The agent reads the assembled `CLAUDE.md` in the project root.
  This is a snapshot — it was generated by `cep init` or `cep upgrade` at a specific
  point in time.
- **During the session:** The agent may edit `templates/CLAUDE.md.base` (the source
  template). These edits do NOT affect the currently-loaded CLAUDE.md.
- **After the session:** Raymond runs `cep upgrade ~/projects/cep` to regenerate
  CLAUDE.md from the updated template. The new instructions take effect on the next
  session.

This means the agent can safely modify its own template without worrying about
mid-session instruction changes. It's analogous to editing a config file while the
program is running — the changes take effect on restart.

**Important:** When editing the template, be precise. The template contains `{{PLACEHOLDER}}`
markers that get substituted by the CLI's `assemble_claude_md()` function using sed/awk.
Don't break these markers. Test any template changes by running `cep diff` on a managed
project to preview the output.

## Project Structure

```
~/projects/cep/
├── bin/cep                      # The CLI — single bash script, the entire runtime
├── templates/
│   ├── CLAUDE.md.base           # The base template — THIS IS THE PRODUCT
│   └── PROJECT_KICKOFF.md       # Interactive planning guide for new projects
├── hooks/                       # (empty) Future: lifecycle hooks for cep commands
├── lib/                         # (empty) Future: shared bash functions extracted from bin/cep
├── .registry/projects           # Plain text list of managed project paths (gitignored)
├── VERSION                      # Single line: current version string (e.g., "0.2.0")
├── README.md                    # The front door — install, usage, philosophy
├── ROADMAP.md                   # Themed groups of planned work + ideas parking lot
├── .cep/                        # CEP managing itself (dogfooding)
│   ├── CLAUDE.local.md          # This file
│   ├── mikado.yaml              # Current goal decomposition
│   ├── sessions.yaml            # Session index
│   ├── logs/                    # Session logs
│   ├── blog/                    # Session blog posts
│   ├── guidebook/               # Living reference book about CEP internals
│   └── decisions/               # Architecture Decision Records
├── CLAUDE.md                    # Assembled by `cep init` — do not edit directly
└── .gitignore                   # Ignores .registry/
```

## What Is NOT in Scope Right Now

- **Go rewrite.** The bash CLI works. The rewrite happens when the feature set
  stabilizes, not before. Don't refactor toward Go idioms.
- **Multi-machine support.** Hardware auto-detection, machine registry, task routing —
  all deferred. CEP runs on one machine at a time.
- **Notifications (Gotify).** Useful but not critical for dogfooding. Deferred.
- **User onboarding / genericization.** CEP is Raymond's tool. The interactive
  interview, user profiles, and generic templates are future work. The template
  currently hardcodes Raymond's context and that's fine.
- **`cep publish`.** Converting guidebook to HTML/PDF/epub. Nice to have, not now.
- **Git workflow conventions.** Branch-per-experiment, PR docs — deferred until the
  current workflow feels limiting.
- **Context window management.** Summary artifacts, fresh-chat prompts, clipboard
  integration — deferred.

## Project-Specific Conventions

### Testing

CEP is a bash CLI. Testing means:
- **Functional tests:** Run `cep init` on a temp directory, verify the output structure.
  Run `cep upgrade`, verify CLAUDE.md changes while CLAUDE.local.md is preserved.
  Run `cep diff`, verify the diff output makes sense.
- **Template tests:** Assemble a CLAUDE.md with known inputs, verify placeholder
  substitution works correctly. Verify multiline CLAUDE.local.md content is injected
  properly.
- **Use a test harness in bash** — a simple `assert_equals`/`assert_file_contains`
  approach is sufficient. No need for bats or shunit2 unless complexity demands it.

### Editing the Template

The template (`templates/CLAUDE.md.base`) is the most important file in the project.
Changes to it affect every CEP-managed project on the next `cep upgrade`. Treat
template changes with the same care as a public API change:
- Test the assembled output with `cep diff` on at least one managed project
- Document the change in the session log with clear reasoning
- Consider whether the change needs a version bump

### Version Bumping

CEP uses semantic versioning. The version lives in the `VERSION` file (single line).
Bump the version when:
- The template changes in a way that affects agent behavior (minor or major)
- New CLI commands are added (minor)
- Breaking changes to `.cep/` directory structure (major)

Don't bump for: documentation-only changes, roadmap updates, internal refactoring
that doesn't affect assembled output.
